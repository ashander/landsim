% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/migration_matrix.R
\name{migration_matrix}
\alias{migration_matrix}
\title{Create Migration Matrix from a Migration object and a Population object}
\usage{
migration_matrix(population, accessible, migration = list(sigma = 1, normalize
  = 1), kern = migration$kern, sigma = migration$sigma,
  radius = migration$radius, normalize = migration$normalize,
  from = which(accessible), to = from, discretize = migration$discretize,
  ...)
}
\arguments{
\item{population}{Population object or Raster*.}

\item{accessible}{Logical vector indicating which cells in `habitat` that migrants will attempt to go to.}

\item{migration}{Migration object; is overridden by other parameters below.}

\item{kern}{Weighting kernel applied to distances.}

\item{sigma}{Distance scaling for kernel.}

\item{radius}{Maximum distance away to truncate the kernel.}

\item{normalize}{If not NULL, migration weights to accessible locations are set to sum to this (see details).}

\item{from}{The indices of the cells corresponding to rows in the output matrix. [default: non-NA cells]}

\item{to}{The indices of the cells corresponding to columns in the output matrix. [default: same as \code{from}]}

\item{discretize}{Whether or not to "discretize" the kernel first using the \code{discretize_kernel} function.}

\item{...}{Further parameters passed to \code{discretize_kernel}.}
}
\value{
A sparse Matrix \code{M}, where for each pair of cells \code{i} in \code{from} and \code{i} in \code{to},
the value \code{M[i,j]} is
   kern( d[i,j]/sigma )
or, if \code{kern="gaussian"},
   exp( - d[i,j]^2/sigma^2 ) / ( 2 pi sigma^2 ) * (area of a cell)
where \code{d[i,j]} is the distance from \code{from[i]} to \code{to[j]},
if this is greater than \code{min.prob}, and is 0 otherwise.

Summary of how to encode different types of boundary: set absorbing boundary elements to accessible, 
but do not include them in from (and to). Mark reflecting (non-)boundaries as not accessible. 
External boundaries will be reflecting, so if they should be absorbing, you need to extend the raster and set values appropriately.

Migration is possible to each \code{accessible} cell in the Raster*.
If \code{normalize} is not NULL, then for each cell, the set of migration weights to each other accessible cell
within distance \code{radius} is normalized to sum to \code{normalize}.
The resulting matrix may not have rows summing to \code{normalize},
however, if \code{from} is a subset of the \code{accessible} ones.

If not normalized, the kernel is multiplied by the area of the cell (taken to be approximately constant).

The usual way to use this is to call \code{migration_matrix(pop,mig)},
where \code{pop} is a \code{population} object, which contains both the Raster 
and the vector of which locations are accessible;
and \code{mig} is a \code{migration} object containing the kernel, migration radius, etcetera.

Alternatively, \code{population} can be a RasterLayer,
in which case by default all non-NA cells are accessible.

Inaccessible cells included in \code{to},
have zero migration outwards.
Inaccessible cells included in \code{from} behave as usual.
}
\description{
This returns the (sparse) Matrix giving the pseudo-adjacency matrix 
from and to for specified cells in the given Raster, with weights.
}

